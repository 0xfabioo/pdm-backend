import argparse
import json
import re
import subprocess
import sys
from html.parser import HTMLParser
from pathlib import Path
from typing import List, Tuple

import parver
import requests

PROJECT_DIR = Path(__file__).parent.parent
VERSION_RE = re.compile(r"^__version__ *= *([\"'])(.+?)\1 *$", flags=re.M)


class PythonVersionParser(HTMLParser):
    def __init__(self, *, convert_charrefs: bool = True) -> None:
        super().__init__(convert_charrefs=convert_charrefs)
        self._parsing_release_number_span = False
        self._parsing_release_number_a = False
        self.parsed_python_versions: List[str] = []

    def handle_starttag(self, tag: str, attrs: List[Tuple[str, str]]) -> None:
        if tag == "span" and any(
            "release-number" in value for key, value in attrs if key == "class"
        ):
            self._parsing_release_number_span = True
            return

        if self._parsing_release_number_span and tag == "a":
            self._parsing_release_number_a = True

    def handle_endtag(self, tag: str) -> None:
        if self._parsing_release_number_span and tag == "span":
            self._parsing_release_number_span = False

        if self._parsing_release_number_a and tag == "a":
            self._parsing_release_number_a = False

    def handle_data(self, data: str) -> None:
        if self._parsing_release_number_a:
            self.parsed_python_versions.append(data[7:])


def dump_python_version_module(dry_run: bool = False) -> None:
    resp = requests.get("https://python.org/downloads")
    resp_text = resp.text
    parser = PythonVersionParser()
    parser.feed(resp_text)
    python_versions = sorted(parser.parsed_python_versions, reverse=True)
    content = (
        "# Generated by scripts/release.py\n"
        "# fmt: off\n"
        "AVAILABLE_PYTHON_VERSIONS = {}\n"
        "# fmt: on\n".format(json.dumps(python_versions, indent=4))
    )
    if dry_run:
        print("========Generated versions.py========")
        print(content)
        return

    dest_file = PROJECT_DIR / "pdm/pep517/versions.py"
    dest_file.write_text(content, encoding="utf-8")


def _get_current_version():
    from pdm.pep517.metadata import Metadata

    metadata = Metadata(PROJECT_DIR / "pyproject.toml")
    return metadata.version


def _replace_version(new_version: str):
    target = PROJECT_DIR / "pdm/pep517/__init__.py"
    content = target.read_text("utf-8")
    target.write_text(VERSION_RE.sub(f'__version__ = "{new_version}"', content))


def _bump_version(pre=None, major=False, minor=False, patch=True):
    if not any([major, minor, patch]):
        patch = True
    if len([v for v in [major, minor, patch] if v]) != 1:
        print(
            "Only one option should be provided among " "(--major, --minor, --patch)",
            file=sys.stderr,
        )
        sys.exit(1)
    current_version = parver.Version.parse(_get_current_version())
    if pre is None:
        version_idx = [major, minor, patch].index(True)
        version = current_version.replace(pre=None, post=None).bump_release(
            index=version_idx
        )
    else:
        version = current_version.bump_pre(pre)
    version = version.replace(local=None, dev=None)
    return str(version)


def release(dry_run=False, commit=True, pre=None, major=False, minor=False, patch=True):
    dump_python_version_module(dry_run)
    new_version = _bump_version(pre, major, minor, patch)
    print(f"Bump version to: {new_version}")
    if dry_run:
        subprocess.check_call(["towncrier", "--version", new_version, "--draft"])
    else:
        _replace_version(new_version)
        subprocess.check_call(["towncrier", "--yes", "--version", new_version])
        subprocess.check_call(["git", "add", "."])
        if commit:
            subprocess.check_call(["git", "commit", "-m", f"Release {new_version}"])
            subprocess.check_call(
                ["git", "tag", "-a", new_version, "-m", f"v{new_version}"]
            )
            subprocess.check_call(["git", "push"])
            subprocess.check_call(["git", "push", "--tags"])


def parse_args(argv=None):
    parser = argparse.ArgumentParser("release.py")

    parser.add_argument("--dry-run", action="store_true", help="Dry run mode")
    parser.add_argument(
        "--no-commit",
        action="store_false",
        dest="commit",
        default=True,
        help="Do not commit to Git",
    )
    group = parser.add_argument_group(title="version part")
    group.add_argument("--pre", help="Pre tag")
    group.add_argument("--major", action="store_true", help="Bump major version")
    group.add_argument("--minor", action="store_true", help="Bump minor version")
    group.add_argument("--patch", action="store_true", help="Bump patch version")
    group.add_argument(
        "--dump-versions", action="store_true", help="Dump python versions only"
    )

    return parser.parse_args(argv)


if __name__ == "__main__":
    args = parse_args()
    if args.dump_versions:
        dump_python_version_module(args.dry_run)
    else:
        release(args.dry_run, args.commit, args.pre, args.major, args.minor, args.patch)
